this is where elf is putting some musings on insane generalisation atm. 
this will be formalised at some point.

some design considerations for general protocol and protocol stack definition:
a) generating 'holder' fields to be revisited later
b) specification of order of revisiting (both protocol and stack level)
c) clean namespace handling
d) definition of default validators, serialisers, etc
   this would also imply a solid library of generalised default types
e) grouping for defaults, perhaps, as well? (complex protocols would benefit)
   multiple ways of doing this.  first thought was to have groups defined 
   by an enclosing keyword, but this could be very silly if, say, there are
   a large set of fields and a small number of default groups, but the groups
   were noncontinuous.  second thought was to label the groups, which seems 
   much better, and avoids namespace issues.
f) definition of union types (separate from holders because they can be computed
   from prior rather than future data)  this would be a big win for almost
   anything with varlen fields (asn.1, dhcp, etc).  would require an extra 
   slot for getting back type, but thats trivially generated.  
g) the union concept gives rise to an idea of abstracting out sequences of 
   fields and treating them as a single unit with a modifier to attach to
   each field name to maintain uniqueness.  this would make many currently
   hideous protocols entirely trivial.
h) there are three basic procedures that every field needs:
   1) validator (given some data, is it valid for this field?)
   2) writer (create this field)
   3) reader (parse this field... not the same as validator.)
i) validators im thinking of as validity predicates.  should be run after 
   reading and before writing any data.
j) more to come...

some technical musings on definition:
a) it really sounds like im talking about objects, doesnt it?
b) but im not!
c) ha ha!!
d) seriously, now, macros are our friends.  we should be able to generalise 
   protocol definition in such a way that all the relevant lambdas, as well 
   as a record-type for that protocol, are all generated automagically. 
e) records are also are friends. removes some of the naming issue.
f) on the issue of actually handling fuzzings, theres some excellent papers
   and work by oleg, on different means of iterators and selectors.
g) im also drafting up some ideas on generalising lambda chains to be
   autogenerated instead of explicitly defined (not to say that its not possible
   to modify them, or change pieces manually, just something to remove most of
   the gruntwork.)
h) adding to each protocol the ability to identify that protocol via a proc or
   an exact string/u8vector/integer.
i) trying for datalink independence as well with a 'datalink' keyword.
j) more to come...

ill be putting more concepts, code, and docs in here as i develop em.  please
comment.

-elf, 11 aug 2007 
       modified 12 aug 2007


oke, some thoughts on what it should look like...
we need something for field-groups, protocols, and protocol-stacks.
(im using the notation <procedure:min-arity:max-arity> as shorthand, and 
?? to indicate that an element may appear exactly once, even if part of a *
group).  most procedures are 1:3, with the args as follows: 
   1: individual data
   2: data of current record
   3: all previous data as list


<field-group> ::= '(' define-field-group <fg-name> <field-list> ')'

<fg-name> ::= <any scheme identifier, excepting 'union' and 'ref'>

<field-list> ::= '(' fields <field>+ ')'

<field> ::= '(' <field-simple> | <field-union> | <field-ref> ')'

<field-simple> ::= <field-name> <field-size> <field-props>?

<field-union> ::= union <field-name> <field-union-p>+

<field-ref> :: ref <field-name> <field-name> <field-props>?

<field-union-p> ::= '(' <field-union-p-simple> | <field-union-p-ref> ')'

<field-union-p-simple> ::= <field-union-size> <field-props>?

<field-union-p-ref ::= ref <field-name> <field-props>?

<field-union-size> ::= <procedure:1:3>

<field-name> ::= <any scheme identifier, excepting 'union' and 'ref'>

<field-size> ::= <integer> | <procedure:1:3>

<field-props> ::= (<field-exact>?? | <field-default>?? | 
                   <field-validate>?? | <field-read>?? | <field-write>??)*

<field-exact> ::= '(' exact <field-value> ')'

<field-default> ::= '(' default <field-value> ')'

<field-validate> ::= '(' validate <field-validate-proc> <field-delay>? ')'

<field-read> ::= '(' reader <field-proc> <field-delay>? ')'

<field-write> ::= '(' writer <field-proc> <field-delay>? ')'

<field-delay> ::= '(' delay (<integer> | <field-relative> | end) ')'

<field-relative> ::= '(' (before | after) <field-relative-name> ')'

<field-relative-name> ::= ((datalink:)? (<proto-name> ':')* <field-name>) |
                           <proto-name> | datalink

<field-value> ::= <integer> | <string> | <char>

<field-proc> ::= <procedure:1:3> | <default-label>

<field-validate-proc> ::= <field-proc> | <field-value>



<protocol> ::= '(' define-protocol <proto-name> <proto-meta>? <field-list> ')'

<proto-name> ::= <any scheme identifier, except 'datalink' and 'stack'>

<proto-meta> ::= (<proto-ident> | <proto-default> | <proto-field-group> |
                  <proto-datalink>??)*

<proto-ident> ::= '(' identifier <procedure:1:3> ')'

<proto-default> ::= '(' (default-validate | default-reader | default-writer)
                    <procedure:1:3> <proto-default-label>? ')'

<proto-default-label> ::= <any scheme identifier>

<proto-field-group> ::= '(' field-group <fg-name> <field-list> ')'

<proto-transport> ::= '(' proto-is-datalink ')'


::UNFINISHED::

<protocol-stack> ::= '(' define-proto-stack <ps-name> <ps-meta>? <ps-elems> ')'

<ps-name> ::= <any scheme identifier>

<ps-meta> ::= (<ps-datalink> | <ps-resolve>)*

<ps-elems> ::= '(' stack <proto-name>+ ')'

::ENDUNFINISHED::

im thinking define-field-group allows certain things (like type-length-data)
to be cleanly abstracted as a single unit, define-protocol is obvious,
and define-proto-stack creates readers and writers for an entire stack.
if no datalink options are given to proto-stack, it creates a lambda which
takes in a datalink protocol name.   this allows for fast creation of common
stacks (eg tcp/ip) as well as giving datalink tunnelling ability.
(create a protocol stack without datalink resolution but with a datalink 
protocol as its last element, and viola. :) )


thoughts and comments?

-elf, 13 aug 2007


ill put some examples in here soon.  im going to start working on the macro
and record creation stuff right now.


